use directories::ProjectDirs;
use std::{fs, io::Error, path::PathBuf, sync::OnceLock};

pub struct Configuration {
    pub base: ProjectDirs,
    options: OnceLock<Options>,
}

#[derive(serde::Deserialize)]
pub struct Options {
    /// The `ssh-keygen` program or wrapper to invoke.
    #[serde(default = "Options::default_keygen")]
    pub ssh_keygen: Vec<PathBuf>,
}

pub struct IdentityFile {
    pub config_folder: PathBuf,
    pub path: PathBuf,
}

pub struct CertificateAuthority {
    pub path: PathBuf,
    /// The public data, as a single base64 string without spaces.
    pub pub_b64: String,
    pub keytype: CertificateAuthorityType,
}

pub enum CertificateAuthorityType {
    Ed25519,
}

pub struct SignedEphemeralKey {
    /// Path to the private key, as specified in the ssh-keygen command.
    pub path: PathBuf,
}

static SINGLETON: OnceLock<Configuration> = OnceLock::new();

impl Configuration {
    pub fn get() -> Result<&'static Self, Error> {
        let base = ProjectDirs::from("com.github", "HeroicKatora", "git-now").unwrap();

        Ok(SINGLETON.get_or_init(|| Configuration {
            base,
            options: OnceLock::new(),
        }))
    }

    pub fn options(&self) -> Result<&Options, Error> {
        if let Some(opt) = self.options.get() {
            return Ok(opt);
        }

        let file = self.base.config_dir().join("config.json");

        if !file.try_exists()? {
            return Ok(self.options.get_or_init(Options::default));
        }

        let file = fs::File::open(file)?;
        let options: Options = serde_json::de::from_reader(file)?;
        Ok(self.options.get_or_init(|| options))
    }

    pub fn identity_file(&self) -> IdentityFile {
        // The identity certificate is *local* to the project.
        let config_folder = self.base.config_local_dir().to_path_buf();
        let path = config_folder.join("ca");
        IdentityFile {
            config_folder,
            path,
        }
    }
}

impl IdentityFile {
    pub fn exists(&self) -> Result<bool, Error> {
        self.path.try_exists()
    }

    pub fn generate(&self, opt: &Options) -> Result<(), Error> {
        std::fs::create_dir_all(&self.config_folder)?;

        let (ssh_keygen, opts) = opt.ssh_keygen.split_first().unwrap();
        let mut keygen = std::process::Command::new(ssh_keygen);

        keygen
            .args(opts)
            .arg("-f")
            .arg(&self.path)
            .args(["-C", "Generated by and for git-now"])
            // FIXME: support ed25519-sk for security keys, which also makes `-w` relevant for the
            // library supplying those keys.
            .args(["-t", "ed25519"]);

        shell_out_to_command_success(keygen)?;

        Ok(())
    }

    pub fn into_ca(self, opt: &Options) -> Result<CertificateAuthority, Error> {
        let (ssh_keygen, opts) = opt.ssh_keygen.split_first().unwrap();

        let mut public_key = std::process::Command::new(&ssh_keygen);

        public_key
            .args(opts)
            .args(["-e", "-m", "rfc4716"])
            .arg("-f")
            .arg(&self.path);

        let output = public_key.output()?;
        let pub_b64 = CertificateAuthority::parse_rfc4716(&output.stdout)?;

        let mut fingerprint = std::process::Command::new(ssh_keygen);
        fingerprint.args(opts).arg("-l").arg("-f").arg(&self.path);
        let output = fingerprint.output()?;

        let keytype = CertificateAuthority::parse_keytype(&output.stdout)?;

        Ok(CertificateAuthority {
            path: self.path,
            keytype,
            pub_b64,
        })
    }
}

impl CertificateAuthority {
    pub fn create_key(&self, opt: &Options, path: PathBuf) -> Result<SignedEphemeralKey, Error> {
        const FORBID_ALL: &[&str] = &[
            "no-agent-forwarding",
            "no-port-forwarding",
            "no-pty",
            "no-user-rc",
            "no-x11-forwarding",
        ];

        let (ssh_keygen, opts) = opt.ssh_keygen.split_first().unwrap();

        let mut create_key = std::process::Command::new(&ssh_keygen);

        create_key
            .args(opts)
            .args(["-t", "ed25519"])
            .args(["-C", "Ephemerally valid key for ssh-now clients. Do NOT use this in your authorized_keys"])
            // Ephemerally valid key won't need a passphrase!
            .args(["-N", ""])
            .arg("-q")
            .arg("-f")
            .arg(&path);

        shell_out_to_command_success(create_key)?;

        let mut sign_key = std::process::Command::new(&ssh_keygen);

        sign_key
            .args(opts)
            .arg("-s")
            .arg(&self.path)
            .args(["-I", "ssh-now-ephemeral-key"])
            .args(["-V", "-1h:+24h"]);

        for forbid in FORBID_ALL {
            sign_key.args(["-O", forbid]);
        }

        sign_key
            // FIXME: make part of the key, not only its accepted list?
            // .args(["-O", FORCE_COMMAND
            // FIXME: make part of the key, not only its accepted list?
            // .args(["-O", address_spec])
            .arg(&path);

        shell_out_to_command_success(sign_key)?;

        Ok(SignedEphemeralKey { path })
    }

    fn parse_rfc4716(out: &[u8]) -> Result<String, Error> {
        const START: &str = "---- BEGIN SSH2 PUBLIC KEY ----";
        const END: &str = "---- END SSH2 PUBLIC KEY ----";

        let st = std::str::from_utf8(out)
            .map_err(|err| Error::new(std::io::ErrorKind::InvalidData, err))?;

        let mut data = None;
        let mut lines = st.lines();

        let Some(START) = lines.next() else {
            panic!("Error with wrong start");
        };

        // Looping manually to forward more lines.
        while let Some(mut line) = lines.next() {
            if line.contains(": ") {
                while line.ends_with('\\') {
                    let Some(continuation) = lines.next() else {
                        panic!("Error with invalid continuation")
                    };

                    line = continuation;
                }
            }

            let mut buffer = vec![line];
            loop {
                let rest = match lines.next() {
                    Some(END) => {
                        break;
                    }
                    Some(rest) => rest,
                    None => {
                        panic!("Error with wrong end");
                    }
                };

                buffer.push(rest);
            }

            data = Some(buffer.join(""));
        }

        if lines.next().is_some() {
            panic!("Error with pre-end");
        }

        if let Some(data) = data {
            Ok(data)
        } else {
            panic!("Error with missing keydata");
        }
    }

    fn parse_keytype(out: &[u8]) -> Result<CertificateAuthorityType, Error> {
        if out.ends_with(b"(ED25519)\n") {
            Ok(CertificateAuthorityType::Ed25519)
        } else {
            Err(Error::new(
                std::io::ErrorKind::Other,
                "Unrecognized key type in fingerprint for certificate authority",
            ))
        }
    }
}

impl Options {
    fn default_keygen() -> Vec<PathBuf> {
        vec!["ssh-keygen".into()]
    }
}

impl Default for Options {
    fn default() -> Self {
        serde_json::de::from_str("{}").unwrap()
    }
}

fn shell_out_to_command_success(mut command: std::process::Command) -> Result<(), Error> {
    if !command.status()?.success() {
        Err(std::io::Error::new(
            std::io::ErrorKind::Other,
            "ssh-keygen failed",
        ))
    } else {
        Ok(())
    }
}

#[test]
fn can_default_options() {
    let _opt: Options = Default::default();
}
